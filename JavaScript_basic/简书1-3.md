[这里](http://www.jianshu.com/p/cd3fee40ef59)的笔记
## 基础进阶一 ：内存空间详细

> 堆heap：ke-value存储。顺序不同不影响使用。
> 
> 栈stack：  **先进后出，后进先出**
> 
> 队列queue：FIFO 先进先出

### 变量对象与基础数据类型

JavaScript的执行上下文生成之后，会创建一个叫做变量对象的特殊对象，JavaScript的基础数据类型往往都会保存在变量对象中。

> 严格意义上来说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆heap内存区分开来

基础数据类型都是一些简单的数据段，JavaScript中有5中基础数据类型，分别是undefined、null、Boolean、number、string。基础数据类型都是按值访问，因为为我们可以直接操作保存在变量中的实际的值

### 引用数据类型与堆内存

引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上 是操作**对象的引用**而不是实际的对象。因此，引用类型的值都是按引用访问的。

这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。

```
var a1 = 0;   // 变量对象
var a2 = 'this is string'; // 变量对象
var a3 = null; // 变量对象

var b = { m: 20 }; // 变量b存在于变量对象中，{m: 20} 作为对象存在于堆内存中
var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中
```

因此当我们要访问堆内存中的引用数据类型时，实际上我们首先从变量对象中获取了该对象的地址引用（或地址指针），然后再从堆内存中取得我们需要的数据。

JavaScript的内存的生命周期

> 
1. 分配你所需要的内存
2. 使用分配到的内存（读，写）
3. 不需要时将其释放

举个例子

```
var a = 20;// 在内存中给数值变量分配空间
alert(a + 100） ；//使用内存
a = null;//使用完毕后，释放内存空间
```

JavaScript自动垃圾收集机制，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。


## 执行上下文 Execution Context

每当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。

- 全局环境： JavaScript代码运行起来会首先进入该环境
- 函数环境： 当函数被调用执行时，会进入当前函数中执行代码
- eval不建议使用，可忽略

因此在一个JavaScript程序中，必定会产生多个执行上下文，JavaScript引擎会以栈的方式来处理他们，这个栈，我们称其为函数调用栈（call stack）。**栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。**

当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕后，就会自动出栈。

> 注意：函数中，遇到return能直接**终止**可执行代码的执行，因此会直接将当前上下文弹出栈。
总结：

1. 单线程
2. 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待
3. 全局上下文只有唯一的一个，它在浏览器关闭时出栈
4. 函数的执行上下文的个数没有限制
5. 每次某个函数被调用，就会有个新的执行上下文为其创建，即使调用的是自身函数，也是如此。

---
调用一个函数时，一个新的执行上下文就会被创建。而一个执行上下文的声明周期可以分为两个阶段。

> 
- **创建阶段：** 在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。
- **代码执行阶段： **创建完成后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。


## 变量对象 variable Object

变量对象的创建，依次经历了以下几个过程：

1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。
2. 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在**内存地址**的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。
3. 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。

举个例子

```
function foo() {console.log('function foo')}
var foo = 20;
console.log(foo);//20
```

上面的三条规则仅仅适用于变量对象的**创建过程**。也就是执行上下文的创建过程。而`foo=20`是在执行上下文的**执行过程**中运行的，输出结果自然是20。


> 变量对象**创建过程**
创建arguments对象---> 检查function函数声明创建属性---> 检查var变量声明创建属性

> 从上面规则来看，function声明会比var声明优先级更高一点。

未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。

> 这样，如果被问道*变量对象*和*活动对象*有什么区别，就可以自如的应答，他们其实都是统一而对象，只是处于执行上下文的不同声明周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。


## 全局上下文的变量对象

以浏览器中为例，全局对象为window。

