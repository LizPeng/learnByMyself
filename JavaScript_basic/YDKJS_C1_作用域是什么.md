## 1.1 编译原理

在传统编译语言的流程中，程序中的一段源代码会在执行前经理三个步骤，统称为“编译”


> 一. 分词/词法分析（Tokenizing/Lexing）：

 分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过**有状态**还是**无状态**的方式进行的。**有状态-词法分析；无状态-分词；**
> 二. 解析/语法分析(Parsing)

这个过程室将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的数。这个数被称为“抽象语法树”(Abstract Syntax Tree，AST )
> 三. 代码生成

将AST转换为可执行代码的过程被称为代码生成。这个过程与语言，目标平台等息息相关。

## 1.2 理解作用域

### 1.2.1 演员表

> **引擎：**
> 负责整个JavaScript程序的编译及执行过程。
> 
> **编译器：**
> 引擎的好朋友，负责语法分析及代码生成
> 
> **作用域：**
> 引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
	
### 1.2.3 编译器有话要说

当变量出现在赋值操作的左侧进行LHS查询，出现在右侧时进行RHS查询。

RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是视图找到变量的容器本身，从而可以对其进行赋值。

> LHS和RHS并不一定意味着就是“=”赋值操作符的左侧或右侧。
> 
> 将其理解为
> 
> 赋值操作的目标是谁（LHS）
> 
> 谁是赋值操作的源头（RHS）

examples：
---
    consle.log(a);
	//其中对a的引用是一个RHS引用，因为这里a并没有赋予任何值。相应地，需要查找并取得a的值。
	a = 2 ;
	//这里对a的引用是LHS引用，因为实际上我们并不关心当前的值是什么，只是想要为=2 这个赋值操作找到一个目标。

下面的程序，既有LHS也有RHS

    function foo(a) {
    	console.log(a);
    }
    foo(2)

最后一行的foo(..)函数的调用需要对foo进行RHS引用，

小测验

    function foo(a){
    	var b = a ;
    	return a+b;
    }
    var c = foo(2)

1、找到其中所有的LHS查询。3处
2、找到其中所有的RHS查询。4处


## 1.3 作用域嵌套

    function foo(a) {
    	console.log(a + b);
    }
	var b = 2 ;
	foo(2); //4 

对b进行的RHS引用无法在函数foo内部完成，但可以在上一级作用域（全局作用域）中完成。


## 1.4 异常

为什么区分LHS和RHS是一件重要的事情？

因为变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为时不一样的。

如果RHS查询时所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。`foo()`

当引擎执行LHS查询时，如果在全局作用域中也无法找到目标变量，全局作用域中就会创建一个具有该变量的名称，并将其返回给引擎，前提是程序运行在非“严格模式”下。`var a = 'a'`

ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

## 1.5

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。

如果查找的目的是对变量进行赋值，那么就会使用LHS查询；

如果目的是获取变量的值，就会使用RHS查询。

赋值操作符会导致LHS查询，=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

