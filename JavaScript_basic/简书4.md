## [详细图解作用域链与闭包](http://www.jianshu.com/p/21a16d44f150)

![](http://upload-images.jianshu.io/upload_images/599584-aacdb7b7ba2468da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**作用域**：

在js中，将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据**标识符**名称进行变量查找。

> 这里的标识符，指的是变量名或者 函数名

> js中只有全局作用域与函数作用域。
> 
> 作用域与执行上下文是两个完全不同的概念



![](http://upload-images.jianshu.io/upload_images/599584-391af3aad043c028.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
执行上下文生命周期

**作用域链**:是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数 的有序访问。

作用域链是由一系列变量对象组成，我们可以在这个单向同道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。

##　闭包

> 闭包是一种特殊的对象
> 
> 它由两部分组成。执行上下文（代号A），以及在该执行上下文中创建的函数（代号B）。
> 当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。
> 在大多数理解中，包括许多著名的书籍，文章里都以函数B的名字代指这里生成的闭包。而在chrome中，则以执行上下文A的函数名代指闭包。


![](http://upload-images.jianshu.io/upload_images/599584-75ba724cb9e19b51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在上面的图中，红色箭头所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。

**通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量**比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。

需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。

对上面的例子修改，在函数bar声明一个变量c，并在闭包fn中试图访问该变了，运行结果会抛出错误。

```
var fn = null;
function foo() {
    var a = 2;
    function innnerFoo() { 
        console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误
        console.log(a);
    }
    fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn
}

function bar() {
    var c = 100;
    fn(); // 此处的保留的innerFoo的引用
}

foo();
bar();
```

### 闭包的应用场景

> 
- 柯里化：函数式编程
- 模块：