在第一章，我们将“作用域”定义为一套规则，这套规则用来管理引擎如何在当前作用域及嵌套的自作用域中根据标识符名称进行变量查找。

作用域共有两种主要的**工作模型**。第一种：词法作用域，我们进行深入讨论。另外一种动态作用域，仍有一些编程语言bash脚本，perl中。

## 2.1 词法阶段

大部分标准语言编译器的第一个工作阶段叫做词法化（也叫单词化）。词法化的过程会对源码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。

**查找**

作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。

**作用域查找会在找到第一个匹配的标识符时停止**。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”。

无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

词法作用域查找只会查找一级标识符，比如a、b和c。如果代码中引用了foo.bar.baz , 词法作用域只会试图查找foo标识符，找到这个变量后，**对象属性访问规则**会分别接管对bar和baz属性的访问。

## 2.2 欺骗词法

如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（也可以说欺骗）词法作用域呢？

JavaScript有两种机制来实现这个目的。


> **欺骗词法作用域会导致性能下降**

### 2.2.1 eval


eval(..)函数可以接受一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。

在执行evel()之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。

	function foo(str, a){
		eval( str ) ;//欺骗
		console.log(a, b)
	}
	var b = 2 ;
	foo("var b = 3; ", 1);//1, 3

这段代码在foo()内部创建了一个变量b，并遮蔽了外部（全局）作用域中的同名变量。


默认情况下，如果eval()中所执行的代码包含有一个或多个声明(无论是变量还是函数)，就会对eval()所处的词法作用域进行修改。技术上，可以间接调用eva()来使其运行在全局作用域中，并对全局作用域进行修改。

2.2.2 with

with通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。


## blabla 不看 没用了


