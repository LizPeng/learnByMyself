<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title正则</title>
</head>
<body>
  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">Link here</a>
  <h2>正则表达式中的特殊字符</h2>
    <dl>
      <dt class="dt-title">\</dt>
      <dd>在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。<b>还能匹配字符边界</b></dd>
      <dd>也可以将其后的特殊字符，转义为字面量。/a\*/，匹配a*这样的字符串</dd>
      <dd>使用 new RegExp("pattern") 的时候不要忘记将 \ 进行转义，因为 \ 在字符串里面也是一个转义字符。</dd>
      <dt class="dt-title">^</dt>
      <dd>匹配输入的开始。</dd>
      <dt class="dt-title">$</dt>
      <dd>匹配输入的结束。</dd>
      <dt class="dt-title">*</dt>
      <dd>匹配前一个表达式0次或多次。等价于{0,}</dd>
      <dt class="dt-title">+</dt>
      <dd>匹配前面一个表达式1次或者多出。等价于{1,}</dd>
      <dt class="dt-title">?</dt>
      <dd>匹配前面一个表达式0次或者1次。等价于{0,1}</dd>
      <dt class="dt-title">.</dt>
      <dd>（小数点）匹配除换行符之外的任何单个字符；理解成通配符</dd>
      <dd>例如，/.n/将会匹配 "nay, an apple is on the tree" 中的 'an' 和 'on'，但是不会匹配 'nay'。</dd>
      <dt class="dt-title">(x)</dt>
      <dd>匹配'x'并且记住匹配项。括号被称为 捕获括号</dd>
      <dd>
        模式 /(foo) (bar) \1 \2/ 中的 '(foo)' 和 '(bar)' 匹配并记住字符串 "foo bar foo bar" 中前两个单词。模式中的 \1 和 \2 匹配字符串的后两个单词。注意 \1、\2、\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，'bar foo'.replace( /(...) (...)/, '$2 $1' )。
      </dd>
      <dt class="dt-title"></dt>
      <dd></dd>
      <dt class="dt-title"></dt>
      <dd></dd>
    </dl>
  <script>
    /*创建一个正则表达式的两种方式
      一、使用正则表达式字面量
      二、调用RegExp对象的构造函数
    */ 
    const regexA = /ab+c/;
    let regexAv2 = new RegExp("ab+c");
    const regexB = /^[a-zA-Z]+[0-9]*\W?_$/gi;
    let regexBv2 = new RegExp("^[a-zA-Z]+[0-9]*\W?_$","gi")
  </script>
</body>
</html>